 1、快捷键添加功能解释注解
	/**
	 * @param args
	 */
	快捷键：ctrl+shift+j
	
	/*
	 * 
	 */
	 直接输入第一行，然后回车就行
	
2、master公式判断递归调用的时间复杂度
	master公式的使用T(N) = a*T(N/b) + O(N^d)
	1) log(b,a) > d -> 复杂度为O(N^log(b,a))
	2) log(b,a) = d -> 复杂度为O(N^d * logN)
	3) log(b,a) < d -> 复杂度为O(N^d)
	a是分组后，运用到递归操作的样本的操作次数
	b是总样本量分为多少组，也就是子样本量占总样本量的几分之几
	O(N^d)是除了递归操作外，额外需要进行操作需要花费的时间复杂度
	a、b是有可能不相同的，比如将样本量分为了三份，但我只对其中两份进行递归操作
	必须严格按照T(N)这种格式，如果有F(N) = a*T(N/b)+T(N/c) + O(N^d)则不能够使用master公式
	所以Code_03_Recursive的时间复杂度为O(N)
	
3、几种常见排序算法以及其相关特性
	排序算法	平均时间复杂度	空间复杂度		稳定性
	冒泡排序	O(n²)		O(1)		稳定
	插入排序	O(n²)		O(1)		稳定
	选择排序	O(n²)		O(1)		不稳定		//比如：3 3 3 1，排序后第一个3会到最后一位去，顺序混乱
	希尔排序	O(n^1.5)	O(1)		不稳定		
	堆排序	O(N*logN)	O(1)		不稳定		//比如：需要一个小根堆，数据：3 3 3 1，在insert 1的时候，会和第二个3交换，顺序混乱
	快速排序	O(N*logN)	O(N*logN)	不稳定		//比如：3 3 3 3 1，因为是随机找的一个数，在patition的时候会改变其原始顺序
	归并排序	O(N*logN)	O(N)		稳定			//可以有O(1)的空间复杂度
	注：稳定性不是说算法的时间复杂度稳定，而是说在某个数据相等的时候，其相对位置不会发生改变

4、Integer类型比较的时候，可以使用除“==”符号之外的比较符号，判断相等时需要用到equal方法

5、队列和栈都有一个size的方法，可以返回他们的大小

6、队列的添加删除一般是offer与poll，栈一般是push与pop

7、快捷键格式化代码
	ctrl+shift+f
	
8、二分法是有前提要求的：
	二分法的数组必须是有序的